import {
    setPx,
    getUrlParams,
    validatenull
} from "./util";
import config from "./config"; // import crypto from '@/utils/crypto';
import crypto from "@/utils/crypto.min.js"; // import { funEval, uuid } from '@/utils/utils';
import {
    funEval,
    uuid
} from "@/utils/utils.min.js";
import COMMON from "@/config";
import {
    sqlSearch
} from "@/api/sqlSearch";
import token from "./token";
let _this;
export default (() => ({
    props: {
        stylesFormatter: Function,
        dataFormatter: Function,
        titleFormatter: Function,
        labelFormatter: Function,
        clickFormatter: Function,
        dblClickFormatter: Function,
        sqlFormatter: Function,
        formatter: Function,
        echartFormatter: Function,
        dataQuery: Function,
        dataHeader: Function,
        websocketHeader: Function,
        websocketQuery: Function,
        width: {
            type: [Number, String],
            default: 600
        },
        height: {
            type: [Number, String],
            default: 600
        },
        theme: {
            type: String
        },
        child: {
            type: Object,
            default: () => ({})
        },
        sqlChild: {
            type: Object,
            default: () => ({
                filterObj: {}
            })
        },
        sql: {
            type: String
        }, // 接受传递过来的sqlData数据
        sqlData: {
            type: Object,
            default: () => ({})
        }, // 接受传递过来的sqlData数据
        drawConditionList: {
            type: Array,
            default: () => []
        },
        time: {
            type: Number,
            default: 0
        },
        url: {
            type: String
        },
        webSocketUrl: {
            type: String
        },
        authenticationMethod: {
            type: String
        },
        authenticationForm: {
            type: Object,
            default: () => ({})
        },
        disabled: {
            type: Boolean,
            default: !0
        },
        dataType: {
            type: Number,
            default: 0
        },
        dataMethod: {
            type: String,
            default: "get"
        },
        id: {
            type: String,
            default: "main_" + uuid()
        },
        data: {
            type: [Object, String, Array]
        },
        component: {
            type: Object,
            default: () => ({})
        },
        option: {
            type: Object,
            default: () => ({})
        },
        eventList: {
            type: Array,
            default: () => []
        }
    },
    data() {
        return {
            dynamicQuery: {},
            propQuery: {},
            headerHeight: "",
            checkChart: "",
            myChart: "",
            dataChart: [],
            dataAxios: {},
            dataUrl: "",
            dataWebSocketUrl: "",
            key: !1,
            isChart: !1,
            styles: {},
            appendCheck: {},
            appendObj: {},
            appendList: [], // lockReconnect: false,
            websocket: null // timeout: 120000,
            // timeoutObj: null,
            // serverTimeoutObj: null,
        }
    },
    watch: {
        dataAppend(a) {
            console.log("dataAppend"), this.appendObj = {}, this.appendList = [], a ? this.dataChart = [] : this.appendCheck = clearInterval(this.appendCheck), this.updateData()
        },
        echartFormatter() {
            console.log('echartFormatter')
            this.updateChart && this.updateChart()
        },
        url: {
            handler(a) {
                this.dataUrl = a || ""
            },
            deep: !0,
            immediate: !0
        },
        webSocketUrl: {
            handler(a) {
                this.dataWebSocketUrl = a || ""
            },
            deep: !0,
            immediate: !0
        },
        data: {
            handler() {
                this.updateData()
            },
            deep: !0,
            immediate: !0
        },
        width() {
            this.updateData()
        },
        height() {
            this.updateData()
        },
        theme() {
            this.myChart.dispose(), this.init(), this.updateData()
        },
        option: {
            handler() {
                this.myChart && this.isChart && this.updateData()
            },
            deep: !0,
            immediate: !0
        }
    },
    computed: {
        count() {
            return this.option.count
        },
        dataAppend() {
            return this.option.dataAppend
        },
        dataChartLen() {
            return (this.dataChart || []).length
        },
        switchTheme() {
            return this.vaildData(this.option.switchTheme, !1)
        },
        name() {
            const a = this.$el.className.replace(config.name, "");
            return a
        },
        minWidth() {
            const a = this.option.minWidth;
            if (a > this.width) return a
        },
        isApi() {
            return 1 === this.dataType
        },
        isSql() {
            return 2 === this.dataType
        }, // 文字组件新增websocket
        isWebSocket() {
            return 3 === this.dataType
        },
        style() {
            return this.component.style || {}
        },
        styleChartName() {
            const a = {
                width: setPx(this.minWidth || this.width),
                height: setPx(this.height)
            };
            return a
        },
        styleSizeName() {
            return Object.assign({
                width: setPx(this.width),
                height: setPx(this.height)
            }, (() => this.minWidth ? {
                overflowX: "auto",
                overflowY: "hidden"
            } : {})(), this.styles)
        }
    },
    created() {
        _this = this
    },
    mounted() {
        this.init()
    },
    methods: {
        init() {
            const a = this.$refs[this.id];
            a && (this.isChart = config.echart.includes(this.name), this.isChart && (this.myChart = window.echarts.init(a, this.theme)), "datav" == this.name && (this.isChart = !0, this.updateData()))
        },
        getItemRefs() {
            let a = this.$parent.$parent.$refs,
                b = {};
            return Object.keys(a).forEach(c => {
                -1 !== c.indexOf(COMMON.NAME) && (b[c.replace(COMMON.NAME, "")] = a[c][0])
            }), b
        },
        updateClick(a) { // console.log('params==>', params);
            // console.log('this==>', this);
            let b = this.getItemRefs();
            console.log("refList==>", b); // 新增事件数组形式处理方法
            let c = this.eventList;
            for (let e, f = 0; f < c.length; f++) switch (e = c[f], c[f].eventType) {
                case 1: {
                    Object.assign(this.child, e.child), Object.assign(this.sqlChild, e.sqlChild);
                    let c = this.child.index,
                        f = this.child.paramName;
                    if (!(validatenull(f) && validatenull(c))) {
                        let d = {};
                        d[f] = a.value, this.child.keyName && (d[f] = a[this.child.keyName]), Object.keys(b).forEach(a => {
                            c.includes(a) && b[a].updateData(d)
                        })
                    }
                    /**
                     * 新增sqlChild代码  start
                     *
                     */
                    let g = this.sqlChild.index,
                        h = this.sqlChild.fieldType,
                        i = this.sqlChild.filterObj;
                    if (i)
                        for (var d in this.sqlChild.filterObj)
                            if ("index" != d && "fieldType" != d) {
                                let c = this.sqlChild.filterObj[d]; // let value = this.sqlChild[key]
                                if (!(validatenull(g) && validatenull(h) && validatenull(c))) {
                                    let d = {};
                                    d.term = "eq", d.value = 1 == h ? a.value : a.name || a.label, d.fieldId = c, Object.keys(b).forEach(a => {
                                        g.includes(a) && b[a].updateData(d)
                                    })
                                }
                            }
                    /**
                     * 新增sqlChild代码  end
                     *
                     */
                    break
                }
                case 2: { // 隐藏组件
                    let a = e.showHideChild.index;
                    for (let b = 0; b < a.length; b++)
                        for (let c = 0; c < this.$parent.$parent.nav.length; c++)
                            if (a[b] === this.$parent.$parent.nav[c].index) {
                                setTimeout(() => {
                                    this.$parent.$parent.nav[c].display = !0;
                                }, 100);
                                
                                break
                            } // Object.keys(refList).forEach((ele) => {
                    //   if (hideIndexList.includes(ele)){
                    //     // console.log("refList[ele]==>",ele,refList[ele])
                    //     // refList[ele].display = true;
                    //   }
                    // });
                    // for(let j=0;j<this.list.length;j++){
                    //   if (hideIndexList.includes(this.list[j].index)){
                    //     // console.log("refList[ele]",this)
                    //     this.list[j].display = true;
                    //   }
                    // }
                    break
                }
                case 3: {
                    let a = e.showHideChild.index;
                    for (let b = 0; b < a.length; b++)
                        for (let c = 0; c < this.$parent.$parent.nav.length; c++)
                            if (a[b] === this.$parent.$parent.nav[c].index) {
                                setTimeout(() => {
                                    console.log("1111")
                                    this.$parent.$parent.nav[c].display = !1;
                                }, 200);
                                break
                            } // 显示组件
                    break
                }
            }
        },
        updateAppend(a) {
            if (this.validatenull(this.appendObj)) this.appendList = a, this.appendObj = a[0];
            else {
                let b = [];
                for (let c = 0; c < a.length; c++) {
                    const d = a[c];
                    if (d.id === this.appendObj.id) break;
                    else b.push(d)
                }
                this.appendObj = a[0], b.reverse().forEach(a => {
                    this.appendList.unshift(a)
                })
            }
            this.validatenull(this.appendCheck) && (this.appendCheck = setInterval(() => {
                let a = this.appendList.length - 1;
                if (0 <= a) {
                    let b = this.appendList.splice(a, 1)[0];
                    this.dataChart.unshift(b);
                    let c = this.dataChart.length;
                    c > this.count && this.appendList.splice(c - 1, 1)
                }
            }, 2e3))
        },
        updateUrl(a) {
            this.dataUrl = a, this.updateData()
        }, // 更新数据核心方法
        updateData(a = {}) {
            return this.dynamicQuery = Object.assign(this.dynamicQuery, a), new Promise(b => {
                if (this.resetData && this.resetData(), this.key) return;
                this.key = !0;
                const c = () => {
                    this.key = !1;
                    const c = () => {
                        this.isChart && this.updateChart(), this.myChart && (this.bindClick(), this.bindDblClick()), "function" == typeof this.stylesFormatter && (this.styles = this.stylesFormatter(this.dataChart, this.dynamicQuery, this.getItemRefs()) || {}), b(this.dataChart)
                    }; // 动态数据
                    if (this.isApi) { // console.log("isApi==>",this.isApi)
                        const a = a => {
                            this.dataAxios = a;
                            let b = (() => "function" == typeof this.dataFormatter ? this.dataFormatter(a.data, this.dataAxios, this.getItemRefs()) : a.data || {})(); // 延迟效果数据逐步增加
                            this.dataAppend ? this.updateAppend(b) : this.dataChart = b, c()
                        };
                        let b = getUrlParams(this.dataUrl),
                            d = b.url; // dataUrl为计算属性，实际即为父组件传来的url，getUrlParams对url做一个分割，有查询参数就把查询参数提取出来
                        // 只保留请求地址的url
                        if (this.validatenull(d)) return; // 通过this.validatenull调用的validatenull是avue库的一个api它可以用来判断对象、数组、字符串是否为空
                        let e = "function" == typeof this.dataQuery && this.dataQuery(b),
                            f = "function" == typeof this.dataHeader && this.dataHeader(b) || {};
                        console.log(this.dataQuery);
                        let g = Object.assign(b.params, e, this.propQuery, this.dynamicQuery); // console.log({params})
                        this.$axios({
                            method: this.dataMethod,
                            url: d,
                            data: g,
                            headers: f,
                            params: g
                        }).then(b => {
                            a(b)
                        })
                    } else if (this.isSql) {
                        this.sqldatahandle(a, this.sqlData);
                        const b = this.component.prop,
                            d = this.sqlData;
                        sqlSearch(b, d).then(a => {
                            "table" === b ? (this.pageTotal = a.data.total, this.dataChart = a.data.data, this.option.column = a.data.column) : this.dataChart = a.data, c()
                        })
                    } else if (this.isWebSocket) { // console.log('实时数据')
                        let a = getUrlParams(this.dataWebSocketUrl),
                            b = a.url;
                        if (this.validatenull(b)) return;
                        let d = "function" == typeof this.websocketQuery && this.websocketQuery(a),
                            e = "function" == typeof this.websocketHeader && this.websocketHeader(a) || {};
                        this.webSocketInit(b, d, a => {
                            this.dataAxios = a;
                            let b = (() => "function" == typeof this.dataFormatter ? this.dataFormatter(a.data, this.dataAxios, this.getItemRefs()) : a.data || {})();
                            this.dataChart = b, c()
                        })
                    } else this.dataChart = "function" == typeof this.dataFormatter ? this.dataFormatter(this.data, this.dynamicQuery, this.getItemRefs()) : this.data, c()
                };
                this.$nextTick(() => {
                    c(), clearInterval(this.checkChart), 0 !== this.time && this.disabled && (this.checkChart = setInterval(() => {
                        c()
                    }, this.time))
                })
            })
        },
        getLabelFormatter(a) {
            return this.labelFormatter ? this.labelFormatter(a, this.dataChart) : a.value
        }, // 绑定点击事件
        bindClick() {
            this.myChart.off("click"), this.myChart.on("click", a => {
                a.marker && this.clickFormatter && this.clickFormatter({
                    type: this.name,
                    name: a.name,
                    value: a.value[2] || a.value,
                    data: this.dataChart
                }, this.getItemRefs()), this.updateClick(a)
            })
        }, // 绑定双击事件
        bindDblClick() {
            this.myChart.off("dblclick"), this.myChart.on("dblclick", a => {
                a.marker && this.dblClickFormatter && this.dblClickFormatter({
                    type: this.name,
                    name: a.name,
                    value: a.value[2] || a.value,
                    data: this.dataChart
                }, this.getItemRefs())
            })
        }, // 下面俩都是chart的公共的方法,就放这里面共用
        getColor(a, b) {
            const c = this.option.barColor || [];
            if (c[a]) {
                const d = c[a].color1,
                    e = c[a].color2,
                    f = .01 * (c[a].postion || .9);
                return b ? d : e ? {
                    type: "linear",
                    x: 0,
                    y: 0,
                    x2: 0,
                    y2: 1,
                    colorStops: [{
                        offset: 0,
                        color: d // 0% 处的颜色
                    }, {
                        offset: f,
                        color: e // 100% 处的颜色
                    }],
                    global: !1 // 缺省为 false
                } : d
            }
        },
        ishasprop(a, b, c) {
            return Object.assign((() => a ? b : {})(), c)
        }, //  sqldata数据处理函数
        sqldatahandle(a, b) {
            for (var c in b && b.linkCustomFilterS || (b.linkCustomFilterS = {}), b.linkCustomFilterS.filter = [], a.fieldId && (b.linkCustomFilterS[a.fieldId] = a), b.linkCustomFilterS) "filter" != c && "undefined" != c && b.linkCustomFilterS.filter.push({
                ...b.linkCustomFilterS[c]
            })
        }, // websocket初始化
        webSocketInit(a, b, c) {
            let d, e = !1,
                f = 120000,
                g = null,
                h = null,
                i = null;
            const j = function () {
                    console.log("start"), g && clearTimeout(g), h && clearTimeout(h), 0, g = setTimeout(() => {
                        h = setTimeout(() => {
                            _this.websocket.close()
                        }, f)
                    }, f)
                },
                k = function () {
                    e || ( //没连接上会一直重连，设置延迟避免请求过多
                        e = !0, i && clearTimeout(i), i = setTimeout(() => {
                            _this.webSocketInit(a, b, c), e = !1, console.log("\u6B63\u5728\u91CD\u8FDE")
                        }, 5e3))
                },
                l = function () {
                    return new Promise(a => {
                        try {
                            let b = _this.authenticationForm.authenticationUrl,
                                c = {
                                    password: _this.authenticationForm.password,
                                    username: _this.authenticationForm.userName
                                }; // 先获取认证的token
                            const d = axios({
                                method: "post",
                                url: b,
                                data: c
                            });
                            a(d)
                        } catch (a) {
                            console.log(a)
                        }
                    })
                },
                m = function () {
                    _this.websocket.addEventListener("open", () => {
                        console.log(b);
                        const a = JSON.stringify(b);
                        _this.websocket.send(a)
                    }), _this.websocket.addEventListener("message", a => {
                        console.log(a.data), c(a), j()
                    }), _this.websocket.addEventListener("close", () => {
                        console.log("\u94FE\u63A5\u5173\u95ED"), e = !1, k()
                    }), _this.websocket.addEventListener("error", () => {
                        console.log("\u94FE\u63A5\u9519\u8BEF"), _this.dataChart = {
                            value: "\u9519\u8BEF"
                        }
                    })
                };
            try {
                "WebSocket" in window ? "noAuth" === this.authenticationMethod ? (d = a, this.websocket = new WebSocket(d), m()) : l().then(b => {
                    d = a + "?token=" + b.data.token, this.websocket = new WebSocket(d), m()
                }) : alert("\u8BE5\u6D4F\u89C8\u5668\u4E0D\u652F\u6301websocket\uFF01")
            } catch (a) {
                console.log("catch==> e"), k()
            }
            window.onbeforeunload = function () {
                this.websocket.close()
            }
        }
    },
    beforeDestroy() {
        clearInterval(this.checkChart)
    }
}))();